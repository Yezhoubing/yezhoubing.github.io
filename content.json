{"meta":{"title":"Blog","subtitle":"","description":"新人做的博客","author":"Ye Zhoubing","url":"https://www.bilibili.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-17","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-17","excerpt":""}],"posts":[{"title":"多标签","text":"多标签测试","path":"2023/01/02/多标签/","date":"01-02","excerpt":"","tags":[{"name":"tag1","slug":"tag1","permalink":"https://www.bilibili.com/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://www.bilibili.com/tags/tag2/"}]},{"title":"配置静态ip","text":"1.修改对应系统的配置文件在本服务器中，文件路径对应如下 1etc/netplan/01-network-manager-all.yaml 可能要root权限，命令如下：1sudo su 输入账户密码即可 输入命令打开文件： 1sudo vim /etc/netplan/01-network-manager-all.yaml 编辑文件 1i 文件名看之前ipconfig -a显示ip地址的那个 注意：参数修改有空格保存修改并退出 1:wq 应用修改的文件： 1sudo netplan apply 然后输入ifconfig -a就可以查看ip地址是否修改啦 参考博客1、博客2","path":"2022/12/12/配置静态ip/","date":"12-12","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://www.bilibili.com/tags/linux/"}]},{"title":"linux下翻墙","text":"推荐使用clash客户端，使用步骤如下： 1.下载clash在GitHub上搜索，第一个就是 注意版本选择： 2.解压到下载的.tar.gz目录中，输入解压命令 1tar -zxvf filename 再转到解压后的文件中，运行cfw文件启动clash 1./cfw 3.导入节点自己之前购买的用自己的就可以，没有的可以访问这个网址获取免费节点 4.修改端口在setting中，修改network-network proxy，点击设置图标，对应的端口改为clash中显示的端口 然后就能科学上网啦。参考视频 别用最新版的，新版调了vmess协议的适配格式。用0.19.2以前的版本终端上翻墙注意按照上面的步骤的话可以翻墙，但是在终端（命令行）还是没有翻墙，可以输入以下命令查看终端是否翻墙成功。 1curl -i google.com 在当前终端下翻墙，在终端输入 123# 都是跟之前对应的export http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890 在关闭终端后就会失效，打开新的终端就需要重新配置。成功后就是这样的：","path":"2022/12/06/linux下翻墙/","date":"12-06","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://www.bilibili.com/tags/linux/"}]},{"title":"linux","text":"命令行界面的#与$ 符号 意义 # 代表root管理员权限 $ 代表普通用户 linux命令大全一、登录与注销12345678910111) sudo useradd lilei //添加用户 (不能被立即使用，需设置密码 sudo passwd lilei) 2) sudo adduser lilei //添加用户su root 切换为root用户3) login //登录或切换用户4) logout //注销用户（命令行） exit(shell-退出控制台)5) shutdown -h 10 //10分钟后自动关机 shutdown -c //取消6) halt(root用户) //关闭所有进程后自动关机7) poweroff //同上8) shutdown -r 10 //十分钟后自动重启9) init 6 //重启 （0-停机，1-单用户，2-多用户，3-完全多用户，4-图形化，5-安全模式，6-重启）10) reboot //重启 二、目录与文件注：路径要用&#x2F;,不要用\\.&#x2F;表示当前目录，.&#x2F; 一般需要和其他文件夹或者文件结合使用，指代当前目录下的东西。执行文件程序时需要.&#x2F;,因为该程序不在环境变量中。目录绝对路径是以 &#x2F; 开头的，&#x2F; 表示根目录。若想要进入当前目录的下一级某个目录，可以使用 cd 跟上相对路径,这里以切换至 usr 目录为例： 123cd usr/或cd ./usr 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 1) pwd //显示当前工作目录 2) mkdir mydir //创建工作目录 3) cd mydir //更改工作目录 cd .. //转到上层目录 ~ 表示home cd ~ 跳到自己的home目录 4) rmdir mydir //删除工作目录 5) touch myfile //创建文件 6) mv myfile mydir //移动目录或文件 7) cp myfile myfir //复制目录或文件 8) rm -rf mydir //删除目录或文件 9) ls -l myfile //查看文件最后被编辑时间 10) ls -lu myfile //查看文件最后被访问时间 11) touch -at 01011212 myfile //修改文件最后被访问时间 12) ls //列出所有文件和目录 13) ls -a //查看所有文件 14) ls -i //显示文件索引节点号 15) ls -l //详细显示 16) ls -m //以逗号分隔 17) sudo apt-get install tree 18) tree -l//以树状图列出目录内容 19) tree -a //所有 20) tree -i //不以阶梯状 21) tree -s //列出文件或目录大小 22) tree -t //按更改时间 23) file -b myfile //显示目录或文件的详细信息 24) stat myfile //同上## 三、文件内容显示 1) cat &gt; myfile //创建文件并编辑内容（ctrl+D结束编辑） 2) cat -n myfile //查看文件 3) chmod [u/g/o/a][+/-/=][r/w/x] myfile //更改文件权限 u-user,g-group,o-others,a-all . +-添加,--删除,=-重置 . r-read读（4），w-write写（2），x-execute执行（1） 4) more myfile //分页往后显示文件（Space空格） 5) less myfile //分页自由显示文件（Page Down / Page Up） 6) head (-10) myfile //指定显示文件前若干行（默认前10） 7) tail (-10) myfile //指定显示文件后若干行（默认后10）## 四、文件内容处理 1) sort myfile //对文件内容进行排序 2) sort -r myfile //逆序 3) uniq myfile //检查文件中的重复内容 4) grep （-c）‘a’ myfile //在文件中查找指定内容 (显示行号) 5) diff myfile01 myfile02 //对不同文件进行比较 6) diff3 myfile01 myfile02 myfile03 //三个文件 7) sdiff myfile01 myfile02 //合并 8) cmp myfile01 myfile02 //通过字节对不同文件进行比较 9) comm myfile01 myfile02 //对有序文件进行比较 10) cut -b(-c)(-d) 2(3) myfile //对文件内容进行剪切 11) paste myfile02 myfile01 //对文件内容进行粘贴 02-）01 12) wc （-参数） myfile //对文件内容进行统计 （c-字符数,w-单词数,l-行数）## 五、压缩 1) zip myfile.zip myfile //压缩 2) zip -d myfile.zip myfile //添加 3) zip -m myfile.zip myfile //删除 4) unzip -o myfile.zip //解压（覆盖） 5) unzip -n myfile.zip //解压（不覆盖） 6) zipinfo myfile.zip //列出压缩文件信息## 六、获取帮助 1) man ls //获取帮助 2) man -k ls //不清楚完整名字 3) whatis ls //获取帮助 4) help cd / cd –help //获取帮助 -d(简短描述) -s(用法简介) 5) info who //获取帮助## 七、其他命令 1) clear //清除屏幕信息 2) echo xx //显示文本 x=0 echo $x . echo -e \\$x . echo $(pwd) 3) date //显示日期和时间（+%y 年 +%m 月 +%d日） 4) cal //显示当前日期 cal -y 5) ps //查看当前进程 -A(所有) U lilei (用户lilei) 6) kill -9 2315 //终止某一进程 7) ps -ef | grep Jincheng 8) pkill Jincheng 9) killall Jincheng 10) last //显示最近登录系统的用户信息-6列 11) history （10） //显示历史指令-默认1000行 w //查看用户，当登陆系统用户很多的时候，可以在W后面加上某个用户名，则会查看该用户执行任务的情况 web //查看当前登陆到系统的用户及其他信息 12) sudo adduser lilei sudo //给普通用户赋予root权限 13) sudo usermod -G sudo lilei //同上 14) alias l=’ls’ //定义命令别名 15) unalias l //删除别名 16) alias //列出别名## 八、查看修改文件内容 STEP 1: 打开文件vi &#x2F;home&#x2F;test&#x2F;method.R ##打开路径“&#x2F;home&#x2F;test&#x2F;”的名称为“method”类型为“.R”的文件，按PgUp或PgDn或箭头查看 STEP 2: 输入“i”，进入“插入”状态，然后利用方向键定位需要修改的位置，对文档进行修改STEP 3: 修改完成之后，按“ESC”退出“插入”状态，然后输入冒号，英文状态的:，然后输入小写的“wq”保存并退出，输入小写的“q”会直接退出不进行修改保存。1234567891011121314151617181920212223## 九、命令行终端快速退出有三种方式### 1.点击❌号### 2.输入exit### 3.ctrl+d## 十、source命令Linux Source命令及脚本的执行方式解析当我修改了/etc/profile文件，我想让它立刻生效，而不用重新登录；这时就想到用source命令，如:source /etc/profile对source进行了学习，并且用它与sh 执行脚本进行了对比，现在总结一下。source命令：source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。用法： source filename 或 . filenamesource命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。 123456789101112131415161718192021source filename 与 sh filename 及./filename执行脚本的区别在那里呢？1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有”.”是用来表示当前目录的。2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。### 举例说明：1.新建一个test.sh脚本，内容为:A=12.然后使其可执行chmod +x test.sh3.运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell4.运行./test.sh后，也是一样的效果5.运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中### source激活环境用`source activate env_name`激活环境与`conda activate env_name`不同source activate 可以在shell脚本开头处激活虚拟环境，而用conda activate则提示“CommandNotFoundError: Your shell has not been properly configured to use ‘conda activate’.”错误。这点很重要，因为经常需要在脚本中先激活特定的环境，然后在特定环境中执行python脚本。观察下列实例，假设test.sh的代码如下： #! &#x2F;bin&#x2F;bashsource activate python3.6 命令 sh -c “source activate python3.6” 不会对当前shell环境产生影响，因为sh会开启一个子shell，然后在子shell中激活了环境python3.6，然后结束命令退出子shell。 命令 sh -c &quot;conda activate python3.6&quot; 相当于在shell脚本开始处，激活环境,可能会报错，解决办法如下面这篇文章 [解决方案文章](https://blog.csdn.net/weixin_44815943/article/details/109353439)","path":"2022/12/01/linux/","date":"12-01","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.bilibili.com/tags/Linux/"}]},{"title":"scrapy初步使用","text":"parse()方法的参数 response 是start_urls里面的链接爬取后的结果。所以在parse()方法中，我们可以直接对response对象包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求 一.response属性url ：HTTP响应的url地址,str类型 status：HTTP响应的状态码, int类型 headers ：HTTP响应的头部, 类字典类型, 可以调用get或者getlist方法对其进行访问 body：HTTP响应正文, bytes类型 text：文本形式的HTTP响应正文, str类型 1response.text = response.body.decode(response.encoding) encoding：HTTP响应正文的编码 reqeust：产生该HTTP响应的Reqeust对象 meta：即response.request.meta, 在构造Request对象时, 可将要传递给响应处理函数的信息通过meta参数传入, 响应处理函数处理响应时, 通过response.meta将信息提取出来 selector：Selector对象用于在Response中提取数据使用下面详细将,主要是 xpath,css取值之后的处理 xpath(query)：下面详细讲解 css(query) ：下面详细讲解 urljoin(url) ：用于构造绝对url, 当传入的url参数是一个相对地址时, 根据response.url计算出相应的绝对url. 二.Selector对象Selector 对象和SelectorList对象都有以下几种方法。 extract() 返回选中内容的Unicode字符串 extract_first()(SelectorList独有) 返回列表中的第一个元素内容 re(“正则表达式”) 正则提取 re_first()(SelectorList独有) 返回列表中的第一个元素内容 三.CSSresponse.css(‘css选择器’) 返回值是Selector对象 1234567response.css(&#x27;css选择器&#x27;).extract_first() #获取一个response.css(&#x27;css选择器&#x27;).extract() # 获取全部response.css(&#x27;css选择器::attr(属性名)&#x27;).extract() # 获取其中某个属性(response.css(&#x27;css选择器::text&#x27;).extract() #获取标签里的文本 四.xpathresponse.xpath(‘xpath选择器’) 返回值是Selector对象 1234567response.xpath(&#x27;xpath选择器&#x27;).extract_first() #获取一个response.xpath(&#x27;xpath选择器&#x27;).extract() # 获取全部.//a[contains(@class,&quot;link-title&quot;)/text()] # 获取文本.//a[contains(@class,&quot;link-title&quot;)/@href] #获取属性","path":"2022/06/15/scrapy初步使用/","date":"06-15","excerpt":"","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://www.bilibili.com/tags/scrapy/"}]},{"title":"scrapy中response","text":"parse()方法的参数 response 是start_urls里面的链接爬取后的结果。所以在parse()方法中，我们可以直接对response对象包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求 一.response属性url ：HTTP响应的url地址,str类型 status：HTTP响应的状态码, int类型 headers ：HTTP响应的头部, 类字典类型, 可以调用get或者getlist方法对其进行访问 body：HTTP响应正文, bytes类型 text：文本形式的HTTP响应正文, str类型 1response.text = response.body.decode(response.encoding) encoding：HTTP响应正文的编码 reqeust：产生该HTTP响应的Reqeust对象 meta：即response.request.meta, 在构造Request对象时, 可将要传递给响应处理函数的信息通过meta参数传入, 响应处理函数处理响应时, 通过response.meta将信息提取出来 selector：Selector对象用于在Response中提取数据使用下面详细将,主要是 xpath,css取值之后的处理 xpath(query)：下面详细讲解 css(query) ：下面详细讲解 urljoin(url) ：用于构造绝对url, 当传入的url参数是一个相对地址时, 根据response.url计算出相应的绝对url. 二.Selector对象Selector 对象和SelectorList对象都有以下几种方法。 extract() 返回选中内容的Unicode字符串 extract_first()(SelectorList独有) 返回列表中的第一个元素内容 re(“正则表达式”) 正则提取 re_first()(SelectorList独有) 返回列表中的第一个元素内容 三.CSSresponse.css(‘css选择器’) 返回值是Selector对象 1234567response.css(&#x27;css选择器&#x27;).extract_first() #获取一个response.css(&#x27;css选择器&#x27;).extract() # 获取全部response.css(&#x27;css选择器::attr(属性名)&#x27;).extract() # 获取其中某个属性(response.css(&#x27;css选择器::text&#x27;).extract() #获取标签里的文本 四.xpathresponse.xpath(‘xpath选择器’) 返回值是Selector对象 1234567response.xpath(&#x27;xpath选择器&#x27;).extract_first() #获取一个response.xpath(&#x27;xpath选择器&#x27;).extract() # 获取全部.//a[contains(@class,&quot;link-title&quot;)/text()] # 获取文本.//a[contains(@class,&quot;link-title&quot;)/@href] #获取属性","path":"2022/06/15/scrapy中response/","date":"06-15","excerpt":"","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://www.bilibili.com/tags/scrapy/"}]},{"title":"scrapy模拟登录","text":"1234567891011121314151617181920212223242526272829303132333435import scrapyclass LoginSpider(scrapy.Spider): name = &#x27;login&#x27; start_urls = [&#x27;https://github.com/login&#x27;] def parse(self, response): ever_token = response.xpath(&#x27;//*[@id=&quot;login&quot;]/div[4]/form/input[1]/@value&#x27;).extract_first() timestamp_secret = response.xpath(&#x27;//*[@id=&quot;login&quot;]/div[4]/form/div/input[11]/@value&#x27;).extract_first() timestamp = response.xpath(&#x27;//*[@id=&quot;login&quot;]/div[4]/form/div/input[10]/@value&#x27;).extract_first() data = &#123; &quot;commit&quot;: &quot;Sign in&quot;, &quot;authenticity_token&quot;: ever_token, # token每次都会变,可以在login网页中查找到 &quot;login&quot;: &quot;xxx&quot;, # 填成自己的 &quot;password&quot;: &quot;xxx&quot;, # 填成自己的 &quot;webauthn-support&quot;: &quot;supported&quot;, &quot;webauthn-iuvpaa-support&quot;: &quot;unsupported&quot;, &quot;return_to&quot;: &quot;https://github.com/login&quot;, &quot;timestamp&quot;: timestamp, &quot;timestamp_secret&quot;: timestamp_secret &#125; yield scrapy.FormRequest( # 用的就是post方式 url=&#x27;https://github.com/session&#x27;, # post网址 callback=self.after_login, formdata=data ) def after_login(self, response): yield scrapy.Request(&#x27;https://github.com/yezhoubing&#x27;, callback=self.check_login) def check_login(self, response): print(response.xpath(&#x27;html/head/title/text()&#x27;).extract_first()) 用scrapy.FormRequest（）方法发送post请求","path":"2022/06/15/scrapy模拟登录/","date":"06-15","excerpt":"","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://www.bilibili.com/tags/scrapy/"}]},{"title":"scrapy使用selenium","text":"在爬虫文件中 12def __init__(self): self.bro = Chrome() # 默认路径为python.exe所在文件夹 中间件文件,在类中 12345678def process_response(self, request, response, spider): #spider便是爬虫文件中的类 bro = spider.bro # 获取爬虫文件中定义的浏览器对象 new_url = spider.start_urls[0] # 需要的url bro.get(new_url) time.sleep(3) page_text = bro.page_source # 包含动态加载的数据 new_response = HtmlResponse(url=new_url,body=page_text,encoding=&#x27;utf-8&#x27;,request=request) return new_response 在setting中开启中间件 1234DOWNLOADER_MIDDLEWARES = &#123; &#x27;servant_pic.middlewares.ServantPicDownloaderMiddleware&#x27;: 543,&#125;","path":"2022/06/15/scrapy使用selenium/","date":"06-15","excerpt":"","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://www.bilibili.com/tags/scrapy/"}]},{"title":"scrapy异步下载图片","text":"scrapy异步下载图片通过 from scrapy.pipelines.images import ImagesPipeline管道下载，可以考虑自己重写，从而修改默认的方式 爬虫文件123456789101112131415161718192021222324252627282930&quot;&quot;&quot;scrapy异步下载图片&quot;&quot;&quot;import scrapyfrom selenium.webdriver import Chromefrom ..items import ServantPicItemimport pandas as pdimport numpy as npfrom scrapy.pipelines.images import ImagesPipelineclass ServantSpider(scrapy.Spider): name_list = [] img_list = [] name = &#x27;servant&#x27; start_urls = [&#x27;https://fgo.wiki/w/%E8%8B%B1%E7%81%B5%E5%9B%BE%E9%89%B4&#x27;] def parse(self, response): item = ServantPicItem() # 读取本地csv文件 data = pd.read_csv(&quot;link.csv&quot;,usecols=[&quot;图片名称&quot;]) data_array1 = np.array(data.stack()) # 首先将pandas读取的数据转化为array self.name_list = data_array1.tolist() data = pd.read_csv(&quot;link.csv&quot;,usecols=[&quot;图片链接&quot;]) data_array2 = np.array(data.stack()) # 首先将pandas读取的数据转化为array self.img_list = data_array2.tolist() # 然后转化为list形式 # item[&#x27;name&#x27;] = self.name_list item[&#x27;image_urls&#x27;] = self.img_list # 必须是img_urls,这是图片下载文件中有的 yield item setting.py文件12345IMAGES_STORE = &#x27;FGO&#x27; # 没有会自动创建ITEM_PIPELINES = &#123; # &#x27;servant_pic.pipelines.ServantPicPipeline&#x27;: 300, &#x27;scrapy.pipelines.images.ImagesPipeline&#x27;: 300,&#125; 管道文件不需要更改。 items.py文件123import scrapyclass ServantPicItem(scrapy.Item): image_urls = scrapy.Field() 结果运行后会在本地工程下兴建一个FGO文件夹，子文件夹full，full中为下载图片，命名为以图片URL的SHA1值进行保存的","path":"2022/06/15/scrapy异步下载图片/","date":"06-15","excerpt":"","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://www.bilibili.com/tags/scrapy/"}]},{"title":"三线表","text":"三线表格式设置如下换为标题行当出现设置后表格格式还是有问题时，建议检查下图中的标注位置是否框选，尝试框选解决问题","path":"2022/05/29/三线表/","date":"05-29","excerpt":"","tags":[{"name":"word","slug":"word","permalink":"https://www.bilibili.com/tags/word/"}]},{"title":"目录问题","text":"当自动插入目录的文字格式怎么改都改不掉时，可能是由于之前使用格式刷刷出的标题，导致格式不统一 解决办法将开始菜单栏中的标题样式修改并更新，再更新目录便发现字体修改成功","path":"2022/05/29/目录问题/","date":"05-29","excerpt":"","tags":[{"name":"word","slug":"word","permalink":"https://www.bilibili.com/tags/word/"}]},{"title":"题注输入框显示不全","text":"问题因为对话框的尺寸是限死的，内容的高度超过了对话框的高度就会显示不全。但不会影响内容。 解决可以修改题注的格式（注意之前要插入过题注才有题注的样式），修改为图中或比原来的段落行距小解决问题。 然后更新应用 再换回原来的行距（例如之前是1.5倍行距）再更新一次结果：","path":"2022/05/29/题注输入框显示不全/","date":"05-29","excerpt":"","tags":[{"name":"word","slug":"word","permalink":"https://www.bilibili.com/tags/word/"}]},{"title":"mathtype对行间距影响","text":"在写论文时，遇到在word中插入MathType公式后导致行距不一致的问题。 第1种解决方法在几经尝试之后，发现插入word自带的公式并不会导致行距不一问题，就想着将所有的MathType公式都转为word自带的公式进行插入，但重新输入公式太花时间了，因此，找到了一种将MathType公式转换为word自带公式的方法。 打开MathType公式编辑窗口，菜单栏 —&gt; 剪切和复制选项 选择：MathML 2.0 (namespace attr) —&gt; 确定 ![img]https://raw.githubusercontent.com/yezhoubing/yzbimghost/main/img/20220403163810.png) 打开目标Word文档 —&gt; 双击MathType公式（使用MathType打开需要转换的公式）— &gt; 在MathTpye对话框中复制需要转换的公式（或者Ctrl+C） 在Word文档中用Ctrl+V粘贴 —&gt; Create an OMML equation —&gt; Remember my choice —&gt; OK 然后，根据情况进行微调，此时的字体会有变化，需要主义。 第2种解决方法选中该段落打开段落取消 如果定义了文档网络，则对齐到网络该项打勾但不知道会带来什么影响，慎用","path":"2022/04/29/mathtype对行间距影响/","date":"04-29","excerpt":"","tags":[{"name":"mathtype","slug":"mathtype","permalink":"https://www.bilibili.com/tags/mathtype/"}]},{"title":"三线表","text":"三线表格式设置如下换为标题行当出现设置后表格格式还是有问题时，建议检查下图中的标注位置是否框选，尝试框选解决问题","path":"2022/04/29/word/","date":"04-29","excerpt":"","tags":[{"name":"word","slug":"word","permalink":"https://www.bilibili.com/tags/word/"}]},{"title":"html和css规范","text":"html与css的一些规范问题1.命名问题不要用字母大小写，即驼峰命名法；尽量使用小写字母与数字，用下划线连接 2.url结构协议+主机+端口 +路径+资源 eg: 1http://lbs.tianditu.gov.cn/server/MapService.html 3.协议比如 http:&#x2F;&#x2F; https:&#x2F;&#x2F; 具有保密协议，比上一个安全 ftp:&#x2F;&#x2F; 通常用于文件上传或下载 4.注释给一个块添加注释 123&lt;!--这是开始 START--&gt; &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;&lt;!--这是结束 END--&gt; 5.块meta对于搜索引擎 第一条是搜索引擎如果搜索你content中的关键词，你的网页会有机会出现在搜索结果上；第二条是搜索结果标题下的描述 12&lt;meta name=&quot;keywords&quot; content=&quot;关键词1、关键词2&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;关键词1、关键词2&quot;&gt;","path":"2022/03/27/html和css规范/","date":"03-27","excerpt":"","tags":[{"name":"html、css","slug":"html、css","permalink":"https://www.bilibili.com/tags/html%E3%80%81css/"}]},{"title":"keras","text":"Keras1. modelsequential按顺序建立的神经网络，一层加一层 2.layerdense全连接层 123456789# 作为 Sequential 模型的第一层，需要指定输入维度。可以为 input_shape=(16,) 或者 input_dim=16，这两者是等价的。model = Sequential()model.add(Dense(32, input_shape=(16,)))# 现在模型就会以尺寸为 (*, 16) 的数组作为输入，# 其输出数组的尺寸为 (*, 32)# 在第一层之后，就不再需要指定输入的尺寸了,第二层输入的数据是第一层输出的数据，所以只要指定输出即可：model.add(Dense(32)) 3.tanh压缩到-1到1之间 LSTM 滑动窗口windowssize","path":"2022/02/04/keras/","date":"02-04","excerpt":"","tags":[{"name":"机器学习、lstm","slug":"机器学习、lstm","permalink":"https://www.bilibili.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%81lstm/"}]},{"title":"test","text":"测试测试测试","path":"2022/02/03/test-1/","date":"02-03","excerpt":"","tags":[{"name":"测试","slug":"测试","permalink":"https://www.bilibili.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"test","text":"测试测试测试","path":"2022/02/03/test/","date":"02-03","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://www.bilibili.com/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"https://www.bilibili.com/tags/tag2/"},{"name":"linux","slug":"linux","permalink":"https://www.bilibili.com/tags/linux/"},{"name":"Linux","slug":"Linux","permalink":"https://www.bilibili.com/tags/Linux/"},{"name":"scrapy","slug":"scrapy","permalink":"https://www.bilibili.com/tags/scrapy/"},{"name":"word","slug":"word","permalink":"https://www.bilibili.com/tags/word/"},{"name":"mathtype","slug":"mathtype","permalink":"https://www.bilibili.com/tags/mathtype/"},{"name":"html、css","slug":"html、css","permalink":"https://www.bilibili.com/tags/html%E3%80%81css/"},{"name":"机器学习、lstm","slug":"机器学习、lstm","permalink":"https://www.bilibili.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%81lstm/"},{"name":"测试","slug":"测试","permalink":"https://www.bilibili.com/tags/%E6%B5%8B%E8%AF%95/"}]}